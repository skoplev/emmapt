col_index = list()
i
i = 1
# Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })
cols
groups
dlists[[1]]$meta_col
dlists[[2]]$meta_col
cols
# Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })
cols
max_members = max(sapply(cols, length))
max_members
i
cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })
max_members = max(sapply(cols, length))
max_members
cols
cols
cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })
cols
do.call(cbind, cols)
# Create matching local column index accross each of the dlists#
    col_index = list()#
#
    # Loop over experimental groups#
    for (i in 1:length(groups)) {#
#
        # Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })#
#
        # The maximum number of members for the considered experimental group#
        max_members = max(sapply(cols, length))#
#
        # sample with replacement to maximum samples for other data types#
        if (method == "bootstrap") {#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members | length(local_index) == 0) {#
                    return(local_index)#
                } else if (length(local_index) == 1) {#
                    return(rep(local_index, max_members - length(local_index) + 1))#
                } else if (length(local_index) > 1) {#
                    return(#
                        sample(local_index, size=max_members, replace=TRUE)#
                    )#
                } else {#
                    stop("Invalid local_index")  # internal error#
                }#
            })#
        } else if (method == "cyclical") {#
            # no bootstrap, fill up with NA's#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })#
        } else if (method == "average") {#
            # TODO#
            stop("method not implemented")#
        } else {#
            stop("wrong method")#
        }#
        col_index[[i]] = do.call(cbind, cols)  # create matrix of column indices#
    }
method="cyclical"
# Create matching local column index accross each of the dlists#
    col_index = list()#
#
    # Loop over experimental groups#
    for (i in 1:length(groups)) {#
#
        # Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })#
#
        # The maximum number of members for the considered experimental group#
        max_members = max(sapply(cols, length))#
#
        # sample with replacement to maximum samples for other data types#
        if (method == "bootstrap") {#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members | length(local_index) == 0) {#
                    return(local_index)#
                } else if (length(local_index) == 1) {#
                    return(rep(local_index, max_members - length(local_index) + 1))#
                } else if (length(local_index) > 1) {#
                    return(#
                        sample(local_index, size=max_members, replace=TRUE)#
                    )#
                } else {#
                    stop("Invalid local_index")  # internal error#
                }#
            })#
        } else if (method == "cyclical") {#
            # no bootstrap, fill up with NA's#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })#
        } else if (method == "average") {#
            # TODO#
            stop("method not implemented")#
        } else {#
            stop("wrong method")#
        }#
        col_index[[i]] = do.call(cbind, cols)  # create matrix of column indices#
    }
col_index
col_index_mat = do.call(rbind, col_index)
col_index_mat
col_index
group_members = sapply(col_index, nrow)
broup_members
group_members
col_index
col_index_mat
group_members
nrow
col_index
group_members = sapply(col_index, nrow)
group_members
groups
if (!length(group_members) == length(groups)) {#
        stop("Internal, match group inconsistency")#
    }
if (!length(group_members) == length(col_index)) {#
        stop("Internal, match group and col index inconsistent.")#
    }
col_index_mat
group_members
match_group = list()#
    for (k in 1:length(group_members)) {#
        match_group[[k]] = rep(k, nrow(col_index[[k]]))#
    }
match_group
group_members
match_group = list()#
    for (k in 1:length(group_members)) {#
        match_group[[k]] = rep(k, nrow(col_index[[k]]))#
    }#
    match_group = unlist(match_group)
match_group
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
i
j
j = 1
out = list()
out[[j]] = list()
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]
out[[j]]$meta_col$match_group = match_group
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]
out[[j]]$meta_col
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], drop=FALSE]
dlists[[j]]$meta_col
col_index_mat[,j]
x = dlists[[1]]$data
x
x[c(1, NA),]
x[c(1, 2, NA),]
x = dlists[[1]]$meta_col
x
x[1,1]
x[1,]
x[c(1, 2),]
x[c(1, NA),]
col_index_mat[,j]
dlists[[j]]$meta_col
dlists[[j]]$meta_col[col_index_mat[,j]]
dlists[[j]]$meta_col[col_index_mat[,j],]
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row
out[[j]] = list()
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]
out[[j]]$meta_col$match_group = match_group
out[[j]]$meta_col
dlists[[j]]$meta_col[col_index_mat[,j],]
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], drop=FALSE]
class(dlists[[j]]$meta_col)
out[[j]] = list()
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j],]
out[[j]]$meta_col
dim(out[[j]]$meta_col )
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], drop=FALSE]
out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], drop=FALSE]
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]
out[[j]]$meta_col$match_group = match_group
out[[j]]$meta_col$match_group
out[[j]]$meta_col
out[[j]]$meta_row = dlists[[j]]$meta_row
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
library(devtools)#
install("/Users/sk/Google Drive/projects/bdmerge/lib/rlib/bdmerge")
library(devtools)#
install("/Users/sk/Google Drive/projects/bdmerge/lib/rlib/bdmerge")
# Testing parameters#
    n1 = 20  # number of samples of data set 1#
    m1 = 10  # number of features of data set 2#
#
    n2 = 30#
    m2 = 20#
#
    n_exp_ids = 10  # number of string based experimental ids#
#
    # init two random data lists with matching experimental ids#
    dlists = list()#
    dlists[[1]] = makeRandDlist(n1, m1, n_exp_ids)#
    dlists[[2]] = makeRandDlist(n1, m1, n_exp_ids)#
#
    checkDataList(dlists[[1]])#
    checkDataList(dlists[[2]])#
#
    unique(dlists[[1]]$meta_col)#
    unique(dlists[[2]]$meta_col)#
#
    dcomb = mergeDataListsByCol(#
        dlists=dlists, #
        match_conditions=list("id", "id"),#
        matrix_selections=list("data", "data"),#
        method="cyclical"#
        )
dcomb[[1]]$meta_col
dcomb[[2]]$meta_col
dcomb[[1]]$data
dcomb[[2]]$data
# Testing parameters#
    n1 = 5  # number of samples of data set 1#
    m1 = 10  # number of features of data set 2#
#
    n2 = 30#
    m2 = 20#
#
    n_exp_ids = 10  # number of string based experimental ids#
#
    # init two random data lists with matching experimental ids#
    dlists = list()#
    dlists[[1]] = makeRandDlist(n1, m1, n_exp_ids)#
    dlists[[2]] = makeRandDlist(n1, m1, n_exp_ids)#
#
    checkDataList(dlists[[1]])#
    checkDataList(dlists[[2]])#
#
    unique(dlists[[1]]$meta_col)#
    unique(dlists[[2]]$meta_col)#
#
    dcomb = mergeDataListsByCol(#
        dlists=dlists, #
        match_conditions=list("id", "id"),#
        matrix_selections=list("data", "data"),#
        method="cyclical"#
        )#
    dcomb[[1]]$meta_col#
    dcomb[[2]]$meta_col
dcomb[[1]]$data
dcomb[[2]]$data
dlists[[1]]$meta_col
dlists[[2]]$meta_col
# init two random data lists with matching experimental ids#
    dlists = list()#
    dlists[[1]] = makeRandDlist(n1, m1, n_exp_ids)#
    dlists[[2]] = makeRandDlist(n2, m2, n_exp_ids)#
#
    checkDataList(dlists[[1]])#
    checkDataList(dlists[[2]])#
#
    unique(dlists[[1]]$meta_col)#
    unique(dlists[[2]]$meta_col)#
#
    dcomb = mergeDataListsByCol(#
        dlists=dlists, #
        match_conditions=list("id", "id"),#
        matrix_selections=list("data", "data"),#
        method="cyclical"#
        )
dlists[[1]]$meta_col
dlists[[2]]$meta_col
dcomb[[1]]$meta_col
dcomb[[2]]$meta_col
library(bdmerge)#
library(getopt)#
library(rjson)#
#
quantile_filter = 0.5  # combined signal strenght quantile fitler#
# quantile_filter = 0.75  # combined signal strenght quantile fitler
# DEBUG#
rm(list=ls())#
setwd("/Users/sk/Google Drive/projects/bdmerge/bdmergepy")#
opt = list()#
opt$config = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB/config.json"#
opt$output = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB"
quantile_filter = 0.5  # combined signal strenght quantile fitler
# Read config.json file#
config = fromJSON(file=opt$config)#
#
# find two input with the most selected information#
most_information_input_index = order(sapply(config$input, length), decreasing=TRUE)[1:2]#
config$input = config$input[most_information_input_index]#
#
# Get match-select values from all file entries#
match_conditions = lapply(config$input, function(x) {#
        return(x["match-select"])  # returns NULL if not available#
})#
#
# Force match conditions to be vectors#
for (i in 1:length(match_conditions)) {#
    match_conditions[[i]] = unlist(match_conditions[[i]])#
}#
#
# Get matrix-select values from all files#
matrix_selections = lapply(config$input, function(x) {#
    return(x["matrix-select"])#
})#
matrix_selections = unlist(matrix_selections)#
#
data_file_paths = names(config$input)
# Load data specified by config file#
dlists = list()#
for (i in 1:length(data_file_paths)) {#
    path = data_file_paths[[i]]#
    dlists[[i]] = readData(file_path=path)#
}
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
dcomb[[1]]$meta_col
dcomb[[2]]$meta_col
allmissing = allMissingValuesCol(dlists=dcomb, entries=matrix_selections)  # assumes that the data name is the same
exclude = do.call('|', allmissing)
allmissing
exclude = do.call('|', allmissing)
allmissing
dlists=dcomb
entries=matrix_selections
entries
dlists
length(entries) == 1
# make references to matrix#
    matrices = list()#
    for (i in 1:length(dlists)) {#
        matrices[[i]] = dlists[[i]][[entries[i]]]#
    }
lapply(dlists[[1]], dim)
lapply(dlists[[2]], dim)
allmissing = allMissingValuesCol(dlists=dcomb, entries=matrix_selections)  # assumes that the data name is the same
allmissing
# make references to matrix#
    matrices = list()#
    for (i in 1:length(dlists)) {#
        matrices[[i]] = dlists[[i]][[entries[i]]]#
    }
dim(matrices[[1]])
dim(matrices[[2]])
dlists=dlists
match_conditions=match_conditions
matrix_selections=matrix_selections
method="cyclical"
require(plyr)#
#
    # CHECK INPUT#
    # -------------------------------------------------#
    if (length(match_conditions) == 1 & length(dlists) > 1) {#
        # repeat match_conditions#
        match_conditions = rep(list(match_conditions), length(dlists))#
    }#
#
    if (length(matrix_selections) == 1 & length(dlists) > 1) {#
        matrix_selections = rep(list(matrix_selections), length(dlists))#
    }#
#
    if (!length(match_conditions) == length(dlists)) {#
        stop("Data lists and match_conditions do not agree")#
    }#
#
    # Check and format#
    for (j in 1:length(dlists)) {#
        checkDataList(dlists[[j]])#
#
        # Test if provided row_id is valid#
        if (!all(match_conditions[[j]] %in% colnames(dlists[[j]]$meta_col))) {#
            stop("invalid col id not found in meta_col: ", match_conditions[[j]])#
        }#
#
        dlists[[j]]$meta_col = as.data.frame(dlists[[j]]$meta_col)#
        dlists[[j]]$meta_row = as.data.frame(dlists[[j]]$meta_row)#
#
        # Check match condition and ensure consistent string format#
        for (k in 1:length(match_conditions[[j]])) {#
            if (class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "integer" | #
                class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "numeric")#
            {#
                dlists[[j]]$meta_col[[match_conditions[[j]][k]]] = format(as.numeric(dlists[[j]]$meta_col[[match_conditions[[j]][k]]]), nsmall=1, trim=TRUE)#
            }#
        }#
    }#
#
    # MATCH DATA#
    # -------------------------------------------------------------------#
    # Construct group ids#
    sampleids = list()#
    for (j in 1:length(dlists)) {#
        # construct ids from multiple fields.#
        sampleids[[j]] = apply(#
            dlists[[j]]$meta_col[unlist(match_conditions[[j]])],#
            1, paste, collapse=":"#
        )#
        sampleids[[j]] = gsub(" ", "", sampleids[[j]])  # remove any whitespace#
    }#
    groups = unique(unlist(sampleids))  # get all groups from constructed sampleids#
#
    # Create matching local column index accross each of the dlists#
    col_index = list()#
#
    # Loop over experimental groups#
    for (i in 1:length(groups)) {#
#
        # Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })#
#
        # The maximum number of members for the considered experimental group#
        max_members = max(sapply(cols, length))#
#
        # sample with replacement to maximum samples for other data types#
        if (method == "bootstrap") {#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members | length(local_index) == 0) {#
                    return(local_index)#
                } else if (length(local_index) == 1) {#
                    return(rep(local_index, max_members - length(local_index) + 1))#
                } else if (length(local_index) > 1) {#
                    return(#
                        sample(local_index, size=max_members, replace=TRUE)#
                    )#
                } else {#
                    stop("Invalid local_index")  # internal error#
                }#
            })#
        } else if (method == "cyclical") {#
            # no bootstrap, fill up with NA's#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })#
        } else if (method == "average") {#
            # TODO#
            stop("method not implemented")#
        } else {#
            stop("wrong method")#
        }#
        col_index[[i]] = do.call(cbind, cols)  # create matrix of column indices#
    }#
#
    # Matrix of local (and matched) indicies. One column per dlist#
    col_index_mat = do.call(rbind, col_index)#
#
    # calculate number of entries in each experimental group#
    group_members = sapply(col_index, nrow)#
#
    if (!length(group_members) == length(groups)) {#
        stop("Internal, match group inconsistency")#
    }#
#
    if (!length(group_members) == length(col_index)) {#
        stop("Internal, match group and col index inconsistent.")#
    }#
#
    # create internal match group id#
    match_group = list()#
    for (k in 1:length(group_members)) {#
        match_group[[k]] = rep(k, nrow(col_index[[k]]))#
    }#
    match_group = unlist(match_group)
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
# DEBUG#
rm(list=ls())#
setwd("/Users/sk/Google Drive/projects/bdmerge/bdmergepy")#
opt = list()#
opt$config = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB/config.json"#
opt$output = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB"#
quantile_filter = 0.5  # combined signal strenght quantile fitler#
# Read config.json file#
config = fromJSON(file=opt$config)#
#
# find two input with the most selected information#
most_information_input_index = order(sapply(config$input, length), decreasing=TRUE)[1:2]#
config$input = config$input[most_information_input_index]#
#
# Get match-select values from all file entries#
match_conditions = lapply(config$input, function(x) {#
        return(x["match-select"])  # returns NULL if not available#
})#
#
# Force match conditions to be vectors#
for (i in 1:length(match_conditions)) {#
    match_conditions[[i]] = unlist(match_conditions[[i]])#
}#
#
# Get matrix-select values from all files#
matrix_selections = lapply(config$input, function(x) {#
    return(x["matrix-select"])#
})#
matrix_selections = unlist(matrix_selections)#
#
data_file_paths = names(config$input)#
#
# Load data specified by config file#
dlists = list()#
for (i in 1:length(data_file_paths)) {#
    path = data_file_paths[[i]]#
    dlists[[i]] = readData(file_path=path)#
}#
#
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
dlists=dlists
match_conditions=match_conditions
matrix_selections=matrix_selections
method="cyclical"
require(plyr)#
#
    # CHECK INPUT#
    # -------------------------------------------------#
    if (length(match_conditions) == 1 & length(dlists) > 1) {#
        # repeat match_conditions#
        match_conditions = rep(list(match_conditions), length(dlists))#
    }#
#
    if (length(matrix_selections) == 1 & length(dlists) > 1) {#
        matrix_selections = rep(list(matrix_selections), length(dlists))#
    }#
#
    if (!length(match_conditions) == length(dlists)) {#
        stop("Data lists and match_conditions do not agree")#
    }#
#
    # Check and format#
    for (j in 1:length(dlists)) {#
        checkDataList(dlists[[j]])#
#
        # Test if provided row_id is valid#
        if (!all(match_conditions[[j]] %in% colnames(dlists[[j]]$meta_col))) {#
            stop("invalid col id not found in meta_col: ", match_conditions[[j]])#
        }#
#
        dlists[[j]]$meta_col = as.data.frame(dlists[[j]]$meta_col)#
        dlists[[j]]$meta_row = as.data.frame(dlists[[j]]$meta_row)#
#
        # Check match condition and ensure consistent string format#
        for (k in 1:length(match_conditions[[j]])) {#
            if (class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "integer" | #
                class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "numeric")#
            {#
                dlists[[j]]$meta_col[[match_conditions[[j]][k]]] = format(as.numeric(dlists[[j]]$meta_col[[match_conditions[[j]][k]]]), nsmall=1, trim=TRUE)#
            }#
        }#
    }#
#
    # MATCH DATA#
    # -------------------------------------------------------------------#
    # Construct group ids#
    sampleids = list()#
    for (j in 1:length(dlists)) {#
        # construct ids from multiple fields.#
        sampleids[[j]] = apply(#
            dlists[[j]]$meta_col[unlist(match_conditions[[j]])],#
            1, paste, collapse=":"#
        )#
        sampleids[[j]] = gsub(" ", "", sampleids[[j]])  # remove any whitespace#
    }#
    groups = unique(unlist(sampleids))  # get all groups from constructed sampleids#
#
    # Create matching local column index accross each of the dlists#
    col_index = list()#
#
    # Loop over experimental groups#
    for (i in 1:length(groups)) {#
#
        # Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })#
#
        # The maximum number of members for the considered experimental group#
        max_members = max(sapply(cols, length))#
#
        # sample with replacement to maximum samples for other data types#
        if (method == "bootstrap") {#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members | length(local_index) == 0) {#
                    return(local_index)#
                } else if (length(local_index) == 1) {#
                    return(rep(local_index, max_members - length(local_index) + 1))#
                } else if (length(local_index) > 1) {#
                    return(#
                        sample(local_index, size=max_members, replace=TRUE)#
                    )#
                } else {#
                    stop("Invalid local_index")  # internal error#
                }#
            })#
        } else if (method == "cyclical") {#
            # no bootstrap, fill up with NA's#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })#
        } else if (method == "average") {#
            # TODO#
            stop("method not implemented")#
        } else {#
            stop("wrong method")#
        }#
        col_index[[i]] = do.call(cbind, cols)  # create matrix of column indices#
    }#
#
    # Matrix of local (and matched) indicies. One column per dlist#
    col_index_mat = do.call(rbind, col_index)#
#
    # calculate number of entries in each experimental group#
    group_members = sapply(col_index, nrow)#
#
    if (!length(group_members) == length(groups)) {#
        stop("Internal, match group inconsistency")#
    }#
#
    if (!length(group_members) == length(col_index)) {#
        stop("Internal, match group and col index inconsistent.")#
    }#
#
    # create internal match group id#
    match_group = list()#
    for (k in 1:length(group_members)) {#
        match_group[[k]] = rep(k, nrow(col_index[[k]]))#
    }#
    match_group = unlist(match_group)#
#
    # COPY DATA TO RETURN STRUCTURE#
    # --------------------------------------------------------------#
    # As specified in col_index_mat. Slicing the input data lists using the calculated column indices.#
#
    out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,#
                    # select non NA columns #
                    col_index_mat[,j][!is.na(col_index_mat[,j])]#
                ]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
lapply(out[[1]])
lapply(out[[1]], dim)
lapply(out[[2]], dim)
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
lapply(out[[2]], dim)
lapply(out[[1]], dim)
library(devtools)#
install("/Users/sk/Google Drive/projects/bdmerge/lib/rlib/bdmerge")
# DEBUG#
rm(list=ls())#
setwd("/Users/sk/Google Drive/projects/bdmerge/bdmergepy")#
opt = list()#
opt$config = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB/config.json"#
opt$output = "benchmarks/9QCA2TRJW9BVKIX6DHUX0M7H6H441WHRZF4IDNKPRIMH7Y8IWB"#
quantile_filter = 0.5  # combined signal strenght quantile fitler#
# Read config.json file#
config = fromJSON(file=opt$config)#
#
# find two input with the most selected information#
most_information_input_index = order(sapply(config$input, length), decreasing=TRUE)[1:2]#
config$input = config$input[most_information_input_index]#
#
# Get match-select values from all file entries#
match_conditions = lapply(config$input, function(x) {#
        return(x["match-select"])  # returns NULL if not available#
})#
#
# Force match conditions to be vectors#
for (i in 1:length(match_conditions)) {#
    match_conditions[[i]] = unlist(match_conditions[[i]])#
}#
#
# Get matrix-select values from all files#
matrix_selections = lapply(config$input, function(x) {#
    return(x["matrix-select"])#
})#
matrix_selections = unlist(matrix_selections)#
#
data_file_paths = names(config$input)#
#
# Load data specified by config file#
dlists = list()#
for (i in 1:length(data_file_paths)) {#
    path = data_file_paths[[i]]#
    dlists[[i]] = readData(file_path=path)#
}
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
allmissing = allMissingValuesCol(dlists=dcomb, entries=matrix_selections)  # assumes that the data name is the same
exclude = do.call('|', allmissing)
# exclude[min_columns:length(exclude)] = TRUE#
if (any(exclude)) {#
    dcomb = colSubsetMatchedCollection(dcomb, !exclude)#
}
# Replace missing values with zeros#
for (i in 1:length(dcomb)) {#
    x = dcomb[[i]][[matrix_selections[i]]]#
    dcomb[[i]][[matrix_selections[i]]][is.na(x)] = 0.0#
}
# Norm filter measuring the signal strength#
# It is assumed that the signals are comparable in magnitude.#
norms = list()#
for (i in 1:length(dcomb)) {#
    norms[[i]] = apply(dcomb[[i]][[matrix_selections[i]]], 2, function(col) {#
        return(sqrt(sum(col^2)) / length(col))  # 2-norm#
    })#
}
summed_norm = norms[[1]] + norms[[2]]  # combined signal strength
dcomb = colSubsetMatchedCollection(dcomb, summed_norm >= quantile(summed_norm, quantile_filter))#
# Calculate sample correlations#
sample_cor1 = list()#
sample_cor1$meta_row = dcomb[[1]]$meta_col#
sample_cor1$meta_col = dcomb[[1]]$meta_col#
sample_cor2 = list()#
sample_cor2$meta_row = dcomb[[2]]$meta_col#
sample_cor2$meta_col = dcomb[[2]]$meta_col#
#
sample_cor1$cmat = cor(dcomb[[1]][[matrix_selections[1]]], use="pairwise.complete.obs", method="pearson")#
sample_cor2$cmat = cor(dcomb[[2]][[matrix_selections[2]]], use="pairwise.complete.obs", method="pearson")#
#
results = list()#
results$lower_tri = data.frame(#
    cor1=sample_cor1$cmat[lower.tri(sample_cor1$cmat)],#
    cor2=sample_cor2$cmat[lower.tri(sample_cor2$cmat)]#
)#
#
# results$cor1 = sample_cor1$cmat[lower.tri(sample_cor1$cmat)]#
# results$cor2 = sample_cor1$cmat[lower.tri(sample_cor1$cmat)]#
#
# cor(sample_cor1$cmat[lower.tri(sample_cor1$cmat)], sample_cor2$cmat[lower.tri(sample_cor2$cmat)])#
# plot(sample_cor1$cmat[lower.tri(sample_cor1$cmat)], sample_cor2$cmat[lower.tri(sample_cor2$cmat)])
# DEBUG#
rm(list=ls())#
setwd("/Users/sk/Google Drive/projects/bdmerge/bdmergepy")#
opt = list()#
opt$config = "benchmarks/KQSAU43HSS8JRXDN9MRC6IID8NCSDVXRUIV8MBO8PMV5JVLFGF/config.json"#
opt$output = "benchmarks/KQSAU43HSS8JRXDN9MRC6IID8NCSDVXRUIV8MBO8PMV5JVLFGF"#
quantile_filter = 0.5  # combined signal strenght quantile fitler
# Read config.json file#
config = fromJSON(file=opt$config)#
#
# find two input with the most selected information#
most_information_input_index = order(sapply(config$input, length), decreasing=TRUE)[1:2]#
config$input = config$input[most_information_input_index]#
#
# Get match-select values from all file entries#
match_conditions = lapply(config$input, function(x) {#
        return(x["match-select"])  # returns NULL if not available#
})#
#
# Force match conditions to be vectors#
for (i in 1:length(match_conditions)) {#
    match_conditions[[i]] = unlist(match_conditions[[i]])#
}#
#
# Get matrix-select values from all files#
matrix_selections = lapply(config$input, function(x) {#
    return(x["matrix-select"])#
})#
matrix_selections = unlist(matrix_selections)#
#
data_file_paths = names(config$input)#
#
# Load data specified by config file#
dlists = list()#
for (i in 1:length(data_file_paths)) {#
    path = data_file_paths[[i]]#
    dlists[[i]] = readData(file_path=path)#
}#
#
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )#
#
# dcomb[[1]]$meta_col#
# dcomb[[2]]$meta_col
dlists[[1]]$meta_col
dlists[[2]]$meta_col
dcomb[[1]]$meta_col
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
matrix_selections
match_conditions
dlists=dlists
method="cyclical"
require(plyr)#
#
    # CHECK INPUT#
    # -------------------------------------------------#
    if (length(match_conditions) == 1 & length(dlists) > 1) {#
        # repeat match_conditions#
        match_conditions = rep(list(match_conditions), length(dlists))#
    }#
#
    if (length(matrix_selections) == 1 & length(dlists) > 1) {#
        matrix_selections = rep(list(matrix_selections), length(dlists))#
    }#
#
    if (!length(match_conditions) == length(dlists)) {#
        stop("Data lists and match_conditions do not agree")#
    }#
#
    # Check and format#
    for (j in 1:length(dlists)) {#
        checkDataList(dlists[[j]])#
#
        # Test if provided row_id is valid#
        if (!all(match_conditions[[j]] %in% colnames(dlists[[j]]$meta_col))) {#
            stop("invalid col id not found in meta_col: ", match_conditions[[j]])#
        }#
#
        dlists[[j]]$meta_col = as.data.frame(dlists[[j]]$meta_col)#
        dlists[[j]]$meta_row = as.data.frame(dlists[[j]]$meta_row)#
#
        # Check match condition and ensure consistent string format#
        for (k in 1:length(match_conditions[[j]])) {#
            if (class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "integer" | #
                class(dlists[[j]]$meta_col[[match_conditions[[j]][[k]]]]) == "numeric")#
            {#
                dlists[[j]]$meta_col[[match_conditions[[j]][k]]] = format(as.numeric(dlists[[j]]$meta_col[[match_conditions[[j]][k]]]), nsmall=1, trim=TRUE)#
            }#
        }#
    }
# MATCH DATA#
    # -------------------------------------------------------------------#
    # Construct group ids#
    sampleids = list()#
    for (j in 1:length(dlists)) {#
        # construct ids from multiple fields.#
        sampleids[[j]] = apply(#
            dlists[[j]]$meta_col[unlist(match_conditions[[j]])],#
            1, paste, collapse=":"#
        )#
        sampleids[[j]] = gsub(" ", "", sampleids[[j]])  # remove any whitespace#
    }#
    groups = unique(unlist(sampleids))  # get all groups from constructed sampleids#
#
    # Create matching local column index accross each of the dlists#
    col_index = list()#
#
    # Loop over experimental groups#
    for (i in 1:length(groups)) {#
#
        # Find the local columns for each data list that matches the experimental group.#
        cols = lapply(sampleids, function(ids) {#
            local_index = which(ids == groups[i])#
            if (length(local_index) == 0) {#
                return(NA)  #
            } else {#
                return(local_index)#
            }#
        })#
#
        # Shuffle order such that the cyclical matching is not biased#
        cols = lapply(cols, function(local_index) {#
            return(local_index[sample(1:length(local_index))])#
        })#
#
        # The maximum number of members for the considered experimental group#
        max_members = max(sapply(cols, length))#
#
        # sample with replacement to maximum samples for other data types#
        if (method == "bootstrap") {#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members | length(local_index) == 0) {#
                    return(local_index)#
                } else if (length(local_index) == 1) {#
                    return(rep(local_index, max_members - length(local_index) + 1))#
                } else if (length(local_index) > 1) {#
                    return(#
                        sample(local_index, size=max_members, replace=TRUE)#
                    )#
                } else {#
                    stop("Invalid local_index")  # internal error#
                }#
            })#
        } else if (method == "cyclical") {#
            # no bootstrap, fill up with NA's#
            cols = lapply(cols, function(local_index) {#
                if (length(local_index) == max_members) {#
                    # maximum number of entries#
                    return(local_index)#
                } else {#
                    # less than maximum number entries#
                    return(c(local_index, rep(NA, max_members - length(local_index))))  # fill up with NAs#
                }#
            })#
        } else if (method == "average") {#
            # TODO#
            stop("method not implemented")#
        } else {#
            stop("wrong method")#
        }#
        col_index[[i]] = do.call(cbind, cols)  # create matrix of column indices#
    }#
#
    # Matrix of local (and matched) indicies. One column per dlist#
    col_index_mat = do.call(rbind, col_index)#
#
    # calculate number of entries in each experimental group#
    group_members = sapply(col_index, nrow)#
#
    if (!length(group_members) == length(groups)) {#
        stop("Internal, match group inconsistency")#
    }#
#
    if (!length(group_members) == length(col_index)) {#
        stop("Internal, match group and col index inconsistent.")#
    }#
#
    # create internal match group id#
    match_group = list()#
    for (k in 1:length(group_members)) {#
        match_group[[k]] = rep(k, nrow(col_index[[k]]))#
    }#
    match_group = unlist(match_group)
# COPY DATA TO RETURN STRUCTURE#
    # --------------------------------------------------------------#
    # As specified in col_index_mat. Slicing the input data lists using the calculated column indices.#
#
    out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
out = list()
out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row
if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]#
            }#
        }
out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]
entry
j
col_index_mat[,j]
col_index_mat[,j]
dlists[[j]][[entry]]
out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j]]
dim()
dim(dlists[[j]][[entry]])
col_index_mat[,j]
out[[j]][[entry]] = dlists[[j]][[entry]][,col_index_mat[,j],drop=FALSE]
max(col_index_mat[,j])
max(col_index_mat[,j], na.rm=TRUE)
dim(dlists[[j]][[entry]])
dlists[[j]][[entry]][,c(1, NA)]
class(dlists[[j]][[entry]])
col_index_mat[,j]
out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]
dlists[[j]][[entry]][,col_index_mat[,j], drop=FALSE]
dlists[[j]][[entry]][,c(1, NA)]
dlists[[j]][[entry]][c(1, NA),]
dlists[[j]][[entry]][,c(1, NA)]
dlists[[j]][[entry]][,c(1, NA), exact=FALSE]
dlists[[j]][[entry]][,c(1, NA), excact=TRUE]
dlists[[j]][[entry]][,c(1, NA)]
dlists[[j]][[entry]][,c(1, NA)]
dlists[[j]][[entry]][,col_index_mat[,j]
dlists[[j]][[entry]]
as.matrix(dlists[[j]][[entry]])[c(1, NA),]
as.matrix(dlists[[j]][[entry]])[,c(1, NA)]
out[[j]][[entry]] = as.matrix(dlists[[j]][[entry]])[,col_index_mat[,j], drop=FALSE]
out = list()#
#
    for (j in 1:length(dlists)) {#
        out[[j]] = list()#
        out[[j]]$meta_col = dlists[[j]]$meta_col[col_index_mat[,j], , drop=FALSE]#
        out[[j]]$meta_col$match_group = match_group#
        out[[j]]$meta_row = dlists[[j]]$meta_row#
#
        if (!is.null(matrix_selections)) {#
            # only return selected matrix#
            for (entry in matrix_selections[j]) {#
                out[[j]][[entry]] = as.matrix(dlists[[j]][[entry]])[,col_index_mat[,j], drop=FALSE]#
            }#
        } else {#
            # assume data lists have the exact same matrix names.#
            for (entry in names(dlists[[j]])) {#
                if (entry == "meta_row" | entry == "meta_col") next#
                out[[j]][[entry]] = as.matrix(dlists[[j]][[entry]])[,col_index_mat[,j], drop=FALSE]#
                # note that NA slicing (NA indices yields NA elements) only works for matrices#
            }#
        }#
#
        checkDataList(out[[j]])#
    }
dim(out[[1]])
lapply(out[[1]], dim)
lapply(out[[2]], dim)
library(devtools)#
install("/Users/sk/Google Drive/projects/bdmerge/lib/rlib/bdmerge")
# DEBUG#
rm(list=ls())#
setwd("/Users/sk/Google Drive/projects/bdmerge/bdmergepy")#
opt = list()#
opt$config = "benchmarks/KQSAU43HSS8JRXDN9MRC6IID8NCSDVXRUIV8MBO8PMV5JVLFGF/config.json"#
opt$output = "benchmarks/KQSAU43HSS8JRXDN9MRC6IID8NCSDVXRUIV8MBO8PMV5JVLFGF"#
quantile_filter = 0.5  # combined signal strenght quantile fitler#
# Read config.json file#
config = fromJSON(file=opt$config)#
#
# find two input with the most selected information#
most_information_input_index = order(sapply(config$input, length), decreasing=TRUE)[1:2]#
config$input = config$input[most_information_input_index]#
#
# Get match-select values from all file entries#
match_conditions = lapply(config$input, function(x) {#
        return(x["match-select"])  # returns NULL if not available#
})#
#
# Force match conditions to be vectors#
for (i in 1:length(match_conditions)) {#
    match_conditions[[i]] = unlist(match_conditions[[i]])#
}#
#
# Get matrix-select values from all files#
matrix_selections = lapply(config$input, function(x) {#
    return(x["matrix-select"])#
})#
matrix_selections = unlist(matrix_selections)#
#
data_file_paths = names(config$input)#
#
# Load data specified by config file#
dlists = list()#
for (i in 1:length(data_file_paths)) {#
    path = data_file_paths[[i]]#
    dlists[[i]] = readData(file_path=path)#
}
# Match data according to the provided matching conditions#
dcomb = mergeDataListsByCol(#
    dlists=dlists,#
    match_conditions=match_conditions,#
    matrix_selections=matrix_selections#
    )
# Remove entries that were not matched#
allmissing = allMissingValuesCol(dlists=dcomb, entries=matrix_selections)  # assumes that the data name is the same#
exclude = do.call('|', allmissing)#
#
# exclude[min_columns:length(exclude)] = TRUE#
if (any(exclude)) {#
    dcomb = colSubsetMatchedCollection(dcomb, !exclude)#
}#
#
# min_columns = min(ncol(dlists[[1]][[matrix_selections[1]]]), ncol(dlists[[2]][[matrix_selections[2]]]))
# Replace missing values with zeros#
for (i in 1:length(dcomb)) {#
    x = dcomb[[i]][[matrix_selections[i]]]#
    dcomb[[i]][[matrix_selections[i]]][is.na(x)] = 0.0#
}#
# Norm filter measuring the signal strength#
# It is assumed that the signals are comparable in magnitude.#
norms = list()#
for (i in 1:length(dcomb)) {#
    norms[[i]] = apply(dcomb[[i]][[matrix_selections[i]]], 2, function(col) {#
        return(sqrt(sum(col^2)) / length(col))  # 2-norm#
    })#
}#
#
summed_norm = norms[[1]] + norms[[2]]  # combined signal strength#
#
# Filter according to combined signal strength#
dcomb = colSubsetMatchedCollection(dcomb, summed_norm >= quantile(summed_norm, quantile_filter))
# Calculate sample correlations#
sample_cor1 = list()#
sample_cor1$meta_row = dcomb[[1]]$meta_col#
sample_cor1$meta_col = dcomb[[1]]$meta_col#
sample_cor2 = list()#
sample_cor2$meta_row = dcomb[[2]]$meta_col#
sample_cor2$meta_col = dcomb[[2]]$meta_col#
#
sample_cor1$cmat = cor(dcomb[[1]][[matrix_selections[1]]], use="pairwise.complete.obs", method="pearson")#
sample_cor2$cmat = cor(dcomb[[2]][[matrix_selections[2]]], use="pairwise.complete.obs", method="pearson")#
#
results = list()#
results$lower_tri = data.frame(#
    cor1=sample_cor1$cmat[lower.tri(sample_cor1$cmat)],#
    cor2=sample_cor2$cmat[lower.tri(sample_cor2$cmat)]#
)
454*6
304*6
304*6 / 3
x = seq(1, 10)
x
y = x*2 + rnorn(10)
y = x*2 + rnorm(10)
y
plot(x, y)
fit = lm(y, x)
fit = lm(y~x)
fit
names(fit)
fit$qr
summary(fit)
summary(fit)$r.squared
1.01^10
1.01^20
1.011^20
1600*6.6
4300+1200
5500*6.6
30000/5000000
